import { NextRequest, NextResponse } from 'next/server';
import { promises as fs } from 'fs';
import path from 'path';
import { format } from 'date-fns';

export async function POST(req: NextRequest) {
  try {
    const { selectedLayers } = await req.json();
    
    if (!selectedLayers || !Array.isArray(selectedLayers) || selectedLayers.length === 0) {
      return NextResponse.json(
        { error: "No layers provided or invalid data format" },
        { status: 400 }
      );
    }

    // Generate a unique batch number based on timestamp
    const timestamp = new Date().getTime();
    const batchNumber = Math.floor(1000 + (timestamp % 9000)); // 4-digit number
    const fileName = `LISEC${batchNumber}.TRF`;
    
    // Create directory if it doesn't exist
    const dirPath = path.join(process.cwd(), 'public', 'trf-files');
    try {
      await fs.mkdir(dirPath, { recursive: true });
    } catch (err) {
      console.error('Error creating directory:', err);
    }
    
    const filePath = path.join(dirPath, fileName);
    
    // Generate TRF file content
    const trfContent = generateTrfContent(selectedLayers, batchNumber);
    
    // Write the file
    await fs.writeFile(filePath, trfContent, 'utf8');
    
    // Create a log entry for this generation
    const logEntry = {
      timestamp: new Date().toISOString(),
      fileName,
      layersCount: selectedLayers.length,
      layerIds: selectedLayers.map((layer: any) => layer._id),
    };
    
    try {
      // Log file path
      const logFilePath = path.join(process.cwd(), 'logs', 'trf-generation.log');
      // Create logs directory if it doesn't exist
      await fs.mkdir(path.join(process.cwd(), 'logs'), { recursive: true });
      
      // Append to log file
      let logContent = '';
      try {
        logContent = await fs.readFile(logFilePath, 'utf8');
      } catch (err) {
        // File doesn't exist yet, that's fine
      }
      
      logContent += JSON.stringify(logEntry) + '\n';
      await fs.writeFile(logFilePath, logContent, 'utf8');
    } catch (logErr) {
      console.error('Error writing to log file:', logErr);
      // Don't fail the request if logging fails
    }
    
    // Return success response with file information
    return NextResponse.json({
      success: true,
      message: "TRF file generated successfully",
      fileName: fileName,
      downloadUrl: `/trf-files/${fileName}`,
      layersProcessed: selectedLayers.length,
      generatedAt: new Date().toISOString(),
      batchNumber
    }, { status: 200 });
    
  } catch (error) {
    console.error('Error generating TRF file:', error);
    return NextResponse.json(
      { error: "Failed to generate TRF file", details: error },
      { status: 500 }
    );
  }
}

function generateTrfContent(layers: any[], batchNumber: number): string {
  let content = '';
  
  // Add REL record
  content += '<REL> 02.11 Generated by Abnoos Production System\r\n';
  
  // Group layers by customer/invoice
  const layersByOrder = groupLayersByOrder(layers);
  
  // Process each order group
  Object.entries(layersByOrder).forEach(([orderKey, orderLayers]) => {
    const firstLayer = orderLayers[0];
    const customerName = firstLayer.customer?.name || 'Unknown';
    const orderNumber = firstLayer.invoice?._id || 
                        firstLayer.invoice?.invoiceNumber || 
                        `ORD${batchNumber}`;
    
    const customerNumber = firstLayer.customer?._id || 'CUST001';
    
    // Format dates
    const currentDate = format(new Date(), 'dd/MM/yyyy');
    const productionDate = firstLayer.productionDate ? 
                          format(new Date(firstLayer.productionDate), 'dd/MM/yyyy') : 
                          currentDate;
    
    // Add ORD record - pad with spaces to match format
    content += `<ORD> ${padRight(orderNumber.toString().substring(0, 10), 10)} ${padRight(customerNumber.toString().substring(0, 10), 10)} ${padRight(customerName.substring(0, 40), 40)} ${productionDate} ${currentDate} Gr\r\n`;
    
    // Add POS records for each layer in this order
    orderLayers.forEach((layer, index) => {
      const itemNum = index + 1;
      const idNum = layer.code || `ITEM${itemNum}`;
      const qty = 1; // Assuming quantity is always 1
      
      // Convert dimensions to n/10mm format (multiply by 10)
      const width = Math.round(parseFloat(layer.width) * 10);
      const height = Math.round(parseFloat(layer.height) * 10);
      
      const glassType = layer.glass?.name || '110';
      
      // Add POS record
      content += `<POS> ${padRight(itemNum.toString(), 6)} ${padRight(idNum, 10)} 0000 ${padRight(qty.toString(), 1)} ${padRight(width.toString(), 6)} ${padRight(height.toString(), 6)} ${padRight(glassType, 10)} ${padRight('', 25)}000 00 00 00 0 0 00000 0\r\n`;
      
      // Add TXT record with additional information
      const txtInfo = `${itemNum}-${layer.productionCode || ''}`;
      const companyName = "ABNOOS JAM KARAJ";
      
      content += `<TXT> ${padRight(txtInfo, 80)} ${padRight(companyName, 80)} ${padRight('', 80)} ${padRight(layer.productionCode || '', 80)}\r\n`;
      
      // Add shape information if available
      if (layer.designNumber) {
        content += `<SHP> ${padRight(itemNum.toString(), 6)} ${padRight(width.toString(), 6)} ${padRight(height.toString(), 6)} 0\r\n`;
      }
      
      // Add glass information if available
      if (layer.glass) {
        const glassName = layer.glass.name || 'FLOAT';
        const glassThickness = layer.glass.thickness || '10';
        content += `<GL1> ${padRight(glassName, 20)} ${padRight(glassThickness, 5)} 0\r\n`;
      }
    });
  });
  
  return content;
}

function groupLayersByOrder(layers: any[]): Record<string, any[]> {
  const groups: Record<string, any[]> = {};
  
  layers.forEach(layer => {
    // Use invoice ID or customer ID as the grouping key
    const key = layer.invoice?._id || layer.customer?._id || 'unknown';
    
    if (!groups[key]) {
      groups[key] = [];
    }
    
    groups[key].push(layer);
  });
  
  return groups;
}

function padRight(str: string, length: number): string {
  if (str === undefined || str === null) {
    return ' '.repeat(length);
  }
  return (str.toString() + ' '.repeat(length)).substring(0, length);
}
